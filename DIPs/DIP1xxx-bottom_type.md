#Add Bottom Type

##Abstract

Introduce a bottom type which is a type that has no values.

The primary purpose is to specify
the return type of a function that does not return.


##Links

[Bottom type](https://en.wikipedia.org/wiki/Bottom_type)


##Terminology

For the purpose of this document, the bottom type is referred to
as *Tbottom*, aka \U+22A5, &uptack;.


##Rationale

Being able to specify that a function does not return has
advantages:

1. Smaller/faster code - no stack cleanup code has to be emitted
after such calls, no registers used on that branch need to be
preserved, variables not used on that branch will not be marked
as 'live', variables reassigned on that branch will not affect
other branches.
2. Makes it easier to reason about the code by simplifying control flow.
3. It's necessary to be competitive with other systems programming
languages.
4. RAII cleanup, scope, finally, and catch clauses need not be generated for
such branches.


##Description

Since assert(0) is defined to never return,
it is used to generate a bottom type:

```
alias Tbottom = typeof(assert(0));
```

and is used like:

```
Tbottom fatalError(string message) { ... }
```

Properties of Tbottom:

```
Tbottom.mangleof == "??";
Tbottom.sizeof == 0;
Tbottom.alignsize == 1;
```

Type construction:

```
Tbottom -> Tbottom
const(Tbottom) -> Tbottom
immutable(Tbottom) -> Tbottom
shared(Tbottom) -> Tbottom
inout(Tbottom) -> Tbottom
Tbottom* -> Tbottom
Tbottom[] -> Tbottom
Tbottom[integer] -> Tbottom
T[Tbottom] -> Tbottom
Tbottom[T] -> Tbottom
(Tbottom) -> (Tbottom)
```

A Tbottom is implicitly convertible to any other type.
No other type is implicitly convertible to Tbottom.

##Declarations

A variable, parameter, field or enum may not be declared as
Tbottom.

A function that returns auto may infer the return type as Tbottom.
(Breaking Change - used to be void.)

##Expressions

```
assert(0)
```
has type Tbottom.

```
a || b
a && b
```
b may be of type Tbottom

```
a ? b : c
```

1. If b and c are of type Tbottom, the result type is Tbottom.
2. Else if b is Tbottom, then the result is typeof(c).
3. Else if c is Tbottom, then the result is typeof(b).

```
cast(Tbottom)expression
```
is an error if `expression` is not of type Tbottom.

```
cast(T)expression
```
is allowed if `expression` is of type Tbottom.


Any attempt to use the value of a Tbottom expression is an error.

##Conversion

An expression of type Tbottom can be implicitly converted to any
other type.

A function that returns a Tbottom is covariant with a function that
returns any type T if T is returned via the registers or
the function returning Tbottom is overriding
a function returning T.

It is implementation defined if a type T is returned via the registers.


##Existing Practice

The compiler explicitly marks a handful of functions known
to never return:

```
_d_throw@4
_d_throwc
_d_throwdwarf
_d_assert
_d_assertp
_d_assert_msg
_d_arraybounds
_d_arrayboundsp
_d_switch_error
_Unwind_Resume
_assert
__assert
__assert_rtn
```
Calls to these functions are internally generated by the compiler
to support various semantics. The list is not user extensible,
is implementation-defined, and is not visible to the user.

The compiler also recognizes `throw` statements and `assert(0)`
expressions as never returning. A function that only has leaves
that end with a `throw` statement, `assert(0)`, or a function
call that is already marked as not returning, is marked as not
returning.

However, this relies on the compiler doing semantic analysis of the
function body in advance, which does not happen for declarations
nor for functions upon which attribute inference is not done.

Consider the C Standard function [exit()](https://www.tutorialspoint.com/c_standard_library/c_function_exit.htm).
It does not return, but as the source is not available to the D compiler
it is not marked as such. Thus, to indicate to the compiler that it is
no return, one must write:

```
exit(status); assert(0);
```

putting the burden on the caller of the function, rather than the function
declaration. It's pretty much never seen in practice.


##Alternative

Use an attribute such as `@noreturn`. C++ uses this approach.
This has the awkward result of a function specifying it has
a return type T, but never returns that type.
Other potential uses of a bottom type will not be expressible.
An alias cannot be made from an attribute, and templates cannot
accept attributes as arguments.

The advantage to `@noreturn` is a function that does not return
can be made covariant with a function that returns a value via
a hidden pointer.


##Breaking Changes / Deprecation Process

None known.


##Copyright & License

Copyright (c) 2018 by the D Language Foundation

Licensed under Creative Commons Zero 1.0
