# Use keywords as identifiers with an escape symbol

| Field           | Value                                                           |
|-----------------|-----------------------------------------------------------------|
| DIP:            | 1007                                                            |
| RC#             | 0                                                               |
| Author:         | Basile Burg, b2.temp@gmx.com                                    |
| Implementation: | https://github.com/dlang/dmd/pull/6324                          |
| Status:         |                                                                 |

## Abstract

In the D programming language, keywords are not usable as identifier.
This DIP solves the issue by proposing to use an escape symbol to denote that a keyword is an identifier.

### Links

First formulation of the idea:
* https://forum.dlang.org/post/krmxsuwauzheloeubdfw@forum.dlang.org

Similar feature in other languages:
* http://wiki.freepascal.org/FPC_New_Features_2.6.0#Support_for_.26-escaping_of_keywords
* https://msdn.microsoft.com/en-us/library/x53a06bb.aspx

Wikipedia article about _Stropping_, the method used in the implementation:
* https://en.wikipedia.org/wiki/Stropping_(syntax)#Modern_use

## Description

In D, a keyword cannot be an identifier. 
The D style guide suggests to append an underscore at the end of the identifier that matches to a keyword, for example for `function`:

```D
struct Function {}
Function function_;
```

This system has a major drawback. The underscore is a valid [D identifier](https://dlang.org/spec/lex.html#Identifier).
There is two consequences:
* Without a kind of convention, one can't determine if `function_` is a whole identifier or if the intention is to have `function` as identifier.
* With a convention, the real identifier is still `function_`, which means that any system based on compile-time introspection (such as a serializer) have to process the identifier in a special way.

The solution proposed by this DIP is not only to allow a keyword to be escaped but also to use a non-identifier character (for example an operator) so that the compiler can determine the intention to use a keyword as identifier.

D has a syntax for pre-processing the tokens during the lexical analysis. This feature is barely used.
It's based on the `#` token, which is not an identifier character.
We could use it to turn a keyword into an identifier, using an escape system, like in the _C#_ or _Object Pascal_ languages.

A `#` followed by a keyword would simply mean that what looks to a keyword is actually an identifier.

Technically we would add a rule for [`SpecialTokenSequence`](https://dlang.org/spec/lex.html#special-token-sequence):

```
SpecialTokenSequence:
    # line IntegerLiteral EndOfLine
    # line IntegerLiteral Filespec EndOfLine
    # Keyword

Filespec:
    " Characters "
```

`# Keyword` would turn any `Keyword` into an identifier during the lexical analysis phase.
In the implementation we do a single forward look up to detect if a keyword is located after `#`.
When the detection is positive we patch the token type (the `Token.value` member) of the keyword so that it becomes an identifier. Finally we remove the `#` token from the list.
The next compiler phase, the grammar parsing, is not affected since the constructs are detected using the tokens type and not their textual representation.

Using a special token sequence is advantageous because with any other non-identifier character the scanner performances maybe affected by the forward look up.
Keyword escaping is rarely needed so the escape symbol must itself be a token that's not common.

### Rationale

- It casually happens the case where we need to deserialize an object that contains as member a variable whose the name is a keyword in D but not in the source. 
For such cases, we could use the escape method so that the identifiers match.
- `body` could be used as an identifier without breaking the language (see DIP 1003).
- object inspectors (in user interfaces) can display properties whose names are also keywords.
- possibility to interface with a foreign function that uses a D keyword as identifier, without using `pragma(mangle)`.

### Breaking changes / deprecation process

None.

### Examples

Use `__traits(identifier)` to verify that the variable name for `#delegate` is well the same as the keyword `delegate`.

```D
void main()
{
    string #delegate;
    #delegate = __traits(identifier, #delegate);
    assert(#delegate == "delegate");
}
```

Deserialize and re-serialize a game character with a typical "class" property.

```D
import std.json;

string dat = q{{"class" : "Hobbit", "name" : "Rufus Mugwort"}};

struct Character
{
    string #class;
    string name;
}

Character #char;

JSONValue js = parseJSON(dat);
if (const(JSONValue)* v = "class" in js)
   #char.#class = v.str;
if (const(JSONValue)* v = "name" in js)
   #char.name = v.str;

assert(#char.#class == "Hobbit");
assert(#char.name == "Rufus Mugwort");

#char.#class = "Dwarf";

void write(S)(ref JSONValue v, ref S s)
{
    foreach(member; __traits(allMembers, S))
        v[member] = __traits(getMember, s, member);
}

write(js, #char);
assert(js["class"].str == "Dwarf"); // in "write" member was well equal to "class".
assert("#class" !in js); // another evidence.
```

## Copyright & License

Copyright (c) 2016 by the D Language Foundation

Licensed under [Creative Commons Zero 1.0](https://creativecommons.org/publicdomain/zero/1.0/legalcode.txt)