# Dependency-Carrying Declarations

| Field           | Value                                                      |
|-----------------|------------------------------------------------------------|
| DIP:            | 1005                                                       |
| Author:         | Andrei Alexandrescu (andrei@erdani.com)                    |
| Implementation: | n/a                                                        |
| Status:         | Draft                                                      |

## Abstract

A Dependency-Carrying Declaration is a D declaration that does not require any `import` declaration to be present outside of it. Such declarations encapsulate their own dependencies, which makes dependency relationships more fine-grained than traditional module- and package-level dependencies.

This DIP makes the argument that Dependency-Carrying Declarations are an essential mechanism for building scalable libraries and applications. It proposes a language addition called "inline import", which allows any function and aggregate D declarations to be transformed into a Dependency-Carrying Declaration.

### Links

[Informal forum review](http://forum.dlang.org/post/o2psvk$1m96$1@digitalmars.com)

### Rationale

Consider the following D code:

```d
import std.datetime;
import std.stdio;
void log(string message)
{
    writeln(Clock.currTime, ' ', message);
}
```

Traditionally (though not required by the language), `import`s are placed at the top of the module and then implicitly used by the declarations in the module. This has two consequences. First, the setup establishes a dependency of the current module on two other modules or packages (and by transitivity, on the transitive closure of the modules/packages those depend on). Second, it defines a _relationship at distance_ between the `log` function and the `import`s at the top. As a immediate practical consequence, `log` cannot be moved across the codebase without ensuring the appropriate `import` declarations are present in the target module.

Let us compare and contrast the setup above with the following:

```d
void log(string message)
{
    import std.datetime;
    import std.stdio;
    writeln(Clock.currTime, ' ', message);
}
```

This layout still preserves the dependency of the current module on the two `std` entities because the compiler would need them in order to compile `log`. However, the relationship at distance disappears---`log` encapsulates its dependencies, which migrate together with it. We call such a declaration that does not depend on `import`s outside of it, a _Dependency-Carrying Declaration_.

Consider now the case when `log` is a generic function:

```d
void log(T)(T message)
{
    import std.datetime;
    import std.stdio;
    writeln(Clock.currTime, ' ', message);
}
```

In this case, the current module depends on `std.datetime` and `std.stdio` only if it uses `log` directly from within a non-template function. Otherwise, the `log` generic function is only parsed to an AST (no symbol lookup) and not processed further. Should another module import this module and use `log`, the dependency is realized because `log` needs to be compiled. This makes the module that actually uses `log`---and only it---dependent on `std.datetime` and `std.stdio`, in addition of course to the module that defines `log`.

The same reasoning applies to template `struct`, `class`, or `interface` definitions:

```d
struct FileBuffer(Range)
{
    import std.stdio;
    private File output;
    ...
}
```

Such an entity only realizes the dependencies when actually instantiated, therefore moving the carried dependencies to the point of instantiation.

The analysis above reveals that Dependency-Carrying Declarations have multiple benefits:

* Specifies dependencies at declaration level, not at module level. This allows reasoning about the dependency cost of declarations in separation instead of aggregated at module level.
* Dependency-Carrying Declarations are easier to move around, making for simpler and faster refactorings.
* Dependency-Carrying Declarations allow scalable template libraries. Large libraries (such as D's standard library itself) are customarily distributed in packages and modules grouped by functional areas, such that client code can use the library without needing to `import` many dozens of small modules, each for one specific declaration. Conversely, client code often `import`s a package or module to use just a small fraction of it. Distributing a template library in the form of Dependency-Carrying Declarations creates a scalable, pay-as-you-go setup: The upfront cost of `import`ing such a module is only that of parsing the module source, which can reasonably be considered negligible in the economy of any build. Then, dependencies are pulled on a need basis depending on the declarations used by client code.

Dependency-Carrying Declarations also have drawbacks:

* If most declarations in a module need the same `import`s, then factoring them outside the declarations at top level is simpler and better than repeating them.
* Traditional dependency-tracking tools such as `make` and other build systems assume file-level dependencies and need special tooling (such as `rdmd`) in order to work efficiently.
* Dependencies at the top of a module are easier to inspect quickly than dependencies spread through the module.

On the whole, experience with using Dependency-Carrying Declarations in the D standard library suggests that the advantages outweigh disadvantages considerably. Using local `import`s is considered good style in D code.

#### Inline `import`s

There are declarations that cannot be reformulated in Dependency-Carrying Declaration form. Consider a simple example of a non-template function declaration:

```d
import std.stdio;
void process(File input);
```

It is not possible to declare `process` without `import`ing `std.stdio` outside of it. Another situation is that of template constraints:

```d
import std.range;
struct Buffered(Range) if (isInputRange!Range)
{
    ...
}
```

There are combinations as well:

```d
import std.range, std.stdio;
void fun(Range)(Range r, File f) if (isInputRange!Range)
{
    ...
}
```

In all of these cases the only way to state the declarations is to make the symbols they use visible in the scope outside it, which in turn requires the use of `import` statements separately from the declarations.

This, combined with the ubiquitous use of static introspection and constrained templates, has led to an unpleasant situation in the D standard library whereby it is practically impossible to eliminate `import`s at the top level. To date, in spite of an effort to place `import`s locally, the dependency structure of the D standard library has not clarified visibly because of this limitation.

We propose an addition to the D language that allows the use of the keyword `import` as part of any function and aggregate declaration. When that syntax is used, it instructs the compiler to effect the import before looking up any names in the declaration. To clarify by means of examples, the previous examples would be rewritten as:

```d
void process(File input) import (std.stdio);
struct Buffered(Range) if (isInputRange!Range) import (std.range)
{
    ...
}
```

With this syntax, the `import` is effected only if the declared name is actually looked up. Of course, simple caching will make several imports of the same module as expensive as the first.

The usual grammar of the `import` statement applies with the addition of the parentheses surrounding the import specifiers, with the following consequences:
* The usual lookup rules apply, for example either `import (std.range)` or the more precise `import (std.range.primitives)` may be used to look up `isInputRange`.
* Specific imports can be present as in `import (std.range : isInputRange)` or `import (std.range.primitives : isInputRange)`.
* Renamed imports may be present as in `import (std.range : isInput = isInputRange)`. This specification precludes the use of `isInputRange` and requires the use of `isInput` instead.

The `static import` feature is not available with this syntax. We don't consider this to be a problem seeing as the applicable scope of the `import` is small enough to not cause problems.

The same declaration may have multiple imports (see below for more examples).

Inline imports only apply to function declarations (template or not), struct/union/class/interface declarations (template or not), and template declarations. Currently inline imports do not apply to alias declarations, enumerated types declarations, or variable declarations.

### Lookup rules

When the name of a Dependency-Carrying Declaration is found via lookup, its corresponding inline imports are effected. Then the name is resolved.

The inline imports don't have priority over existing `import`s visible to the declaration. The lookup is equivalent to placing the inline `import`s in the enclosing scope of the declaration, where they participate in name resolution per the current language rules.

### Examples

Below are a few examples taken from the standard library:

```d
auto uninitializedArray(T, I...)(I sizes) nothrow @system
if (isDynamicArray!T && allSatisfy!(isIntegral, I) &&
    hasIndirections!(ElementEncodingType!T))
import (std.meta, std.range, std.traits)
{
    ...
}
```

Alternatively, the declaration may specify the exact symbols needed by using multiple imports:

```d
auto uninitializedArray(T, I...)(I sizes) nothrow @system
if (isDynamicArray!T && allSatisfy!(isIntegral, I) &&
    hasIndirections!(ElementEncodingType!T))
import (std.meta : allSatisfy)
import (std.range : ElementEncodingType)
import (std.traits : hasIndirections, isDynamicArray, isIntegral)
{
    ...
}
```

#### Workarounds and Alternatives

The obvious workaround to the problem that dependencies must be module-level is to simply define many small modules---in the extreme, one per declaration. Each such small module would import the modules on which that declaration depends. For convenience, `package.d` modules may be provided to aggregate several modules. This approach has the following tradeoffs:

* Library authors face a tension between organizing code in logical units pertaining to the problem domain, and organizing code according to low-level dependency details. They will also be forced to routinely navigate large file hierarchies with many files, which may not be the preferred project organization.
* Client code must choose between using detailed import lists or convenient `package.d` imports.
    * If convenient grouped imports are used, the advantage of fine-grained dependency control is lost.
    * If detailed import lists are used, they are verbose and must be updated often. Because it is not an error to not use an imported symbol, over time the import lists will become a large set including the actually needed set, thus eroding the advantage of the approach in the first place. Special tooling and maintenance tasks would be needed to remove unneeded imports once in a while.

We consider such a workaround nonscalable and undesirable for most projects. At the same time we note that this proposal does not preclude such a project organization.

There are a number of alternative approaches that have been (and some still are) considered.

* Full lazy `import`s. Assume all `import`s are lazy without any change in the language. That would allow an idiom by which libraries use fully qualified names everywhere, and the `import`s would be effected only when names are looked up. This would allow scalability but not the dependency-carrying aspect.
* Add syntax to allow for an optional `import` declaration inside declarations:

```d
    void process(import std.stdio)(File input);
    struct Buffered(import std.range)(Range) if (isInputRange!Range)
    {
        ...
    }
```
This has the advantage of being less verbose in case the same module is looked up several times. The disadvantages are a heavier and more ambiguous syntax (two sets of parens for nontemplates, three for templates) and an unclear relationship between the `import`ed entities and the symbols used in the declaration.
* Use `import` as a pseudo-package such that symbols are written like this:

```d
        void process(import.std.stdio.File input);
        struct Buffered(Range) if (import.std.range.isInputRange!Range)
        {
            ...
        }
```
Such an option has an ambiguity problem shown by Timon Gehr: is `import.std.range.isInputRange` looking up symbol `isInputRange` in module/package `std.range`, or the symbol `range.isInputRange` (e.g. a `struct` member) in module/package `std`?
* Stay as close to the existing `import` syntax as possible. This has the advantage of being instantly recognized, but the disadvantage of looking out of place within the declaration:

```d
        void process(File input) import std.stdio;
        struct Buffered(Range) if (isInputRange!Range)
        import std.range;
        {
            ...
        }
```
One syntactical issue is that in this case the semicolon ending the `import` may or may not end the declaration; the scanner (and human reader) would need to look ahead to figure whether a definition continues (by means of an open brace, the `in` keyword, or the `out` keyword), or the declaration ends there.
* Alternatively, the semicolon might be omitted in the approach above. This causes no syntactical ambiguity but makes the hanging `import` declaration even more out of place:
```d
        void process(File input) import std.stdio;
        struct Buffered(Range) if (isInputRange!Range)
        import std.range
        {
            ...
        }
```
* The `with` keyword has been proposed:
```d
        void process(File input) import std.stdio;
        struct Buffered(Range) if (isInputRange!Range)
        with (import std.range)
        {
            ...
        }
```
Arguably this use of `with` is in keeping with its current semantics; for example, `with (EnumName)` introduces the values defined by an enumerated type in the scope it creates.

### Breaking changes / deprecation process

We do not anticipate any breaking changes brought by this language addition. The syntactical construct proposed is currently not accepted.

The inline imports specified with a declaration do not affect its type (e.g. the function type for a function declaration).

The changes to declaration syntax will impact third-party documentation generators, so they would need to be updated. There is an advantage herein---documentation generators (including ddoc itself) can show the user the dependencies that each declaration would incur.

## Copyright & License

Copyright (c) 2016 by the D Language Foundation

Licensed under [Creative Commons Zero 1.0](https://creativecommons.org/publicdomain/zero/1.0/legalcode.txt)

### Reviews
