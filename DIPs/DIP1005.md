# Dependency-Carrying Declarations

| Field           | Value                                                      |
|-----------------|------------------------------------------------------------|
| DIP:            | 1005                                                       |
| Author:         | Andrei Alexandrescu (andrei@erdani.com)                    |
| Implementation: | n/a                                                        |
| Status:         | Draft                                                      |

## Abstract

A Dependency-Carrying Declaration is a D declaration that does not require any `import` declaration to be present outside of it. Such declarations encapsulate their own dependencies, which makes dependency relationships more fine-grained than traditional module- and package-level dependencies.

This DIP makes the argument that Dependency-Carrying Declarations are an essential mechanism for building scalable libraries and applications. It proposes a language addition called "inline import", which allows any function and aggregate D declarations to be transformed into a Dependency-Carrying Declaration.

### Links

[Informal forum review](http://forum.dlang.org/post/o2psvk$1m96$1@digitalmars.com)

### Rationale

Consider the following D code:

```d
import std.datetime;
import std.stdio;
void log(string message)
{
    writeln(Clock.currTime, ' ', message);
}
```

Traditionally (though not required by the language), `import`s are placed at the top of the module and then implicitly used by the declarations in the module. This has two consequences. First, the setup establishes a dependency of the current module on two other modules or packages (and by transitivity, on the transitive closure of the modules/packages those depend on). Second, it defines a _relationship at distance_ between the `log` function and the `import`s at the top. As a immediate practical consequence, `log` cannot be moved across the codebase without ensuring the appropriate `import` declarations are present in the target module.

Let us compare and contrast the setup above with the following:

```d
void log(string message)
{
    import std.datetime;
    import std.stdio;
    writeln(Clock.currTime, ' ', message);
}
```

This layout still preserves the dependency of the current module on the two `std` entities because the compiler would need them in order to compile `log`. However, the relationship at distance disappears---`log` encapsulates its dependencies, which migrate together with it. We call such a declaration that does not depend on `import`s outside of it, a _Dependency-Carrying Declaration_.

Consider now the case when `log` is a generic function:

```d
void log(T)(T message)
{
    import std.datetime;
    import std.stdio;
    writeln(Clock.currTime, ' ', message);
}
```

In this case, the current module depends on `std.datetime` and `std.stdio` only if it uses `log` directly from within a non-template function. Otherwise, the `log` generic function is only parsed to an AST (no symbol lookup) and not processed further. Should another module import this module and use `log`, the dependency is realized because `log` needs to be compiled. This makes the module that actually uses `log`---and only it---dependent on `std.datetime` and `std.stdio`, in addition of course to the module that defines `log`.

The same reasoning applies to template `struct`, `class`, or `interface` definitions:

```d
struct FileBuffer(Range)
{
    import std.stdio;
    private File output;
    ...
}
```

Such an entity only realizes the dependencies when actually instantiated, therefore moving the carried dependencies to the point of instantiation.

The analysis above reveals that Dependency-Carrying Declarations have multiple benefits:

* Specifies dependencies at declaration level, not at module level. This allows reasoning about the dependency cost of declarations in separation instead of aggregated at module level.
* Dependency-Carrying Declarations are easier to move around, making for simpler and faster refactorings.
* Dependency-Carrying Declarations allow scalable template libraries. Large libraries (such as D's standard library itself) are customarily distributed in packages and modules grouped by functional areas, such that client code can use the library without needing to `import` many dozens of small modules, each for one specific declaration. Conversely, client code often `import`s a package or module to use just a small fraction of it. Distributing a template library in the form of Dependency-Carrying Declarations creates a scalable, pay-as-you-go setup: The upfront cost of `import`ing such a module is only that of parsing the module source, which can reasonably be considered negligible in the economy of any build. Then, dependencies are pulled on a need basis depending on the declarations used by client code.

Dependency-Carrying Declarations also have drawbacks:

* If most declarations in a module need the same `import`s, then factoring them outside the declarations at top level is simpler and better than repeating them.
* Traditional dependency-tracking tools such as `make` and other build systems assume file-level dependencies and need special tooling (such as `rdmd`) in order to work efficiently.
* Dependencies at the top of a module are easier to inspect quickly than dependencies spread through the module.

On the whole, experience with using Dependency-Carrying Declarations in the D standard library suggests that the advantages outweigh disadvantages considerably. Using local `import`s is considered good style in D code.

#### Inline `import`s

There are declarations that cannot be reformulated in Dependency-Carrying Declaration form. Consider a simple example of a non-template function declaration:

```d
import std.stdio;
void process(File input);
```

It is not possible to declare `process` without `import`ing `std.stdio` outside of it. Another situation is that of template constraints:

```d
import std.range;
struct Buffered(Range) if (isInputRange!Range)
{
    ...
}
```

There are combinations as well:

```d
import std.range, std.stdio;
void fun(Range)(Range r, File f) if (isInputRange!Range)
{
    ...
}
```

In all of these cases the only way to state the declarations is to make the symbols they use visible in the scope outside it, which in turn requires the use of `import` statements separately from the declarations.

This, combined with the ubiquitous use of static introspection and constrained templates, has led to an unpleasant situation in the D standard library whereby it is practically impossible to eliminate `import`s at the top level. To date, in spite of an effort to place `import`s locally, the dependency structure of the D standard library has not clarified visibly because of this limitation.

We propose an addition to the D language that allows the use of the keyword `import` as part of any function and aggregate declaration. When that syntax is used, it instructs the compiler to effect the import before looking up any names in the declaration. To clarify by means of examples, the previous examples would be rewritten as:

```d
void process(File input) import (std.stdio);
struct Buffered(Range) if (isInputRange!Range) import (std.range)
{
    ...
}
```

With this syntax, the `import` is effected only if the declared name is actually looked up. Of course, simple caching will make several imports of the same module as expensive as the first.

The usual grammar of the `import` statement applies with the addition of the parentheses surrounding the import specifiers, with the following consequences:
* The usual lookup rules apply, for example either `import (std.range)` or the more precise `import (std.range.primitives)` may be used to look up `isInputRange`.
* Specific imports can be present as in `import (std.range : isInputRange)` or `import (std.range.primitives : isInputRange)`.
* Renamed imports may be present as in `import (std.range : isInput = isInputRange)`. This specification precludes the use of `isInputRange` and requires the use of `isInput` instead.

The `static import` feature is not available with this syntax. We don't consider this to be a problem seeing as the applicable scope of the `import` is small enough to not cause problems.

The same declaration may have multiple imports (see below for more examples).

Inline imports only apply to function declarations (template or not), struct/union/class/interface declarations (template or not), and template declarations. Currently inline imports do not apply to alias declarations, enumerated types declarations, or variable declarations.

### Lookup rules

When the name of a Dependency-Carrying Declaration is found via lookup, its corresponding inline imports are effected. Then the name is resolved.

The inline imports don't have priority over existing `import`s visible to the declaration. The lookup is equivalent to placing the inline `import`s in the enclosing scope of the declaration, where they participate in name resolution per the current language rules.

### Examples

Below are a few examples taken from the standard library:

```d
auto uninitializedArray(T, I...)(I sizes) nothrow @system
if (isDynamicArray!T && allSatisfy!(isIntegral, I) &&
    hasIndirections!(ElementEncodingType!T))
import (std.meta, std.range, std.traits)
{
    ...
}
```

Alternatively, the declaration may specify the exact symbols needed by using multiple imports:

```d
auto uninitializedArray(T, I...)(I sizes) nothrow @system
if (isDynamicArray!T && allSatisfy!(isIntegral, I) &&
    hasIndirections!(ElementEncodingType!T))
import (std.meta : allSatisfy)
import (std.range : ElementEncodingType)
import (std.traits : hasIndirections, isDynamicArray, isIntegral)
{
    ...
}
```

#### Workaround: Increasing Granularity of Modules

The obvious workaround to the problem that dependencies must be module-level is to simply define many small modules---in the extreme, one per declaration. Each such small module would import the modules on which that declaration depends. For convenience, `package.d` modules may be provided to aggregate several modules. This approach has the following tradeoffs:

* Library authors face a tension between organizing code in logical units pertaining to the problem domain, and organizing code according to low-level dependency details. They will also be forced to routinely navigate large file hierarchies with many files, which may not be the preferred project organization.
* Client code must choose between using detailed import lists or convenient `package.d` imports.
    * If convenient grouped imports are used, the advantage of fine-grained dependency control is lost.
    * If detailed import lists are used, they are verbose and must be updated often. Because it is not an error to not use an imported symbol, over time the import lists will become a large set including the actually needed set, thus eroding the advantage of the approach in the first place. Special tooling and maintenance tasks would be needed to remove unneeded imports once in a while.

We consider such a workaround nonscalable and undesirable for most projects. It puts in tension the convenience of coarse-granular organization and the organizational advantage of of fine-grained dependencies. This proposal eliminates the tension between the two, making them affordable simultaneously.

At the same time we note that this proposal does not preclude such a project organization.

#### Alternative: Lazy Imports

Assume all `import`s are lazy without any change in the language. (This has already been implemented in the SDC compiler.) The way the scheme works, all `import`s seen are not yet executed but instead saved in a list of package/module names. Following that, the actual imports are triggered by one of two situations.

First, consider the current module looks up a fully specified name:

```d
import module_a, module_b;
void fun(T)(T value) if (module_a.condition!T)
{
    return module_b.process(value);
}
void fun(T)(T value) if (is(T == int)) { ... }
```

In this situation:

* If `fun` is never looked up, neither `module_a` nor `module_b` needs to be loaded.
* If `fun(42)` is used, even though the second overload is a match, then `module_a` must be loaded in order to ensure that `module_a.condition!int` is false so as to avoid ambiguity.
* If `fun` is called with a non-`int` value, `module_a` is loaded to evaluate the template constraint. If the constraint is true, then `module_b` is also loaded so as to look up `process`.

Let us note that full specification of symbols used may be enabled with ease by using the `static import` feature. We will henceforth refer to this setup as "the `static import` setup".

Second, consider the situation (arguably more frequent in today's D code) when the current module does not fully specify names used. Instead, it imports the appropriate modules and relies on lookup to resolve symbols appropriately:

```d
import module_a, module_b;
void fun(T)(T value) if (condition!T)
{
    return process(value);
}
void fun(T)(T value) if (is(T == int)) { ... }
```

In this situation:

* If `fun` is never used, neither module must be loaded.
* If `fun` is looked up, it will trigger an unspecified lookup for `condition`. This will trigger loading of both `module_a` and `module_b` (and generally all imports in the current module) so as to look up `condition` and ensure no ambiguity.

The same applies to the setup in which `module_a` is imported with specifics:

```d
import module_a, module_b;
void fun(T)(T value) if (condition!T)
{
    return process(value);
}
void fun(T)(T value) if (is(T == int)) { ... }
```

In this case, module `module_b` still needs to be opened if `fun` is looked up to ensure no ambiguity exists for `condition`.

Finally, there is the case when all `import`s specify the list of symbols imported:

```d
import module_a : condition;
import module_b : process;
void fun(T)(T value) if (condition!T)
{
    return process(value);
}
void fun(T)(T value) if (is(T == int)) { ... }
```

In this case, fine-grained loading of modules is possible: each module is loaded only if a symbol inside it is used. We refer to this setup as "the selective `import` setup".

To generalize the observations above, fine-grained loading of modules is possible under either (or a combination of) the following circumstances: (a) the `static import` setup; (b) the selective `import` setup.

Our assessment of this setup is as follows. The advantages are:

* Fine-grained loading of imports is achieved with no changes in the language definition, only the implementation.
* Project discipline may be enforced with relative ease, either manually or by means of simple tools. The rule is: "All private imports must be either `static import` or selective `import`".

The disadvantages are:

* The fine-grained _dependency structure_ is not attained by the selective `import` approach. A declaration using unspecified names does not clarify which `import`s it implicitly relies on. The relationship at distance remains between the `import` and the use thereof.
* The `static import` does not share the issue above, at the cost of being cumbersome to use---all imported symbols must use full lookup everywhere. A reasonable engineering approach would be to define shorter names:

```d
    static import std.range.primitives;
    alias isInputRange = std.range.primitives.isInputRange;
    alias isForwardRange = std.range.primitives.isInputRange;
    ...
```
    Such scaffolding is of course undesirable in the first place. Also, at least by the current language rules, such `alias` definitions would need to load the module anyway so as to ensure the name does exist. In order for this idiom to work, it would require subtle changes to the language that specify how certain `alias` declarations are exempt from early checking and delayed to the first actual use.
* In either setup, `import`s are collapsed into their union, usually at the top of the module. Such lists grow out of sync with the actual code because during maintenance the programmer working on one declaration is not motivated to simultaneously alter a module-level `import` list shared by all declarations in the module. Over time, the `import`s grow into a superset of the actual depedencies used by the code, and do not reflect which declarations cause which imports even when accurate.
* The "carrying" aspect is lost: any migration of a declaration to another module must be followed by awkwardly doing surgery on the `import` list of the receiving module. Again, the migration may leave unused `import`s in the module the declaration is taken from. The only recourse to keeping the `import` list in sync is special tooling or time-consuming discipline (search the module for uses, attempt recompilation).

Although we consider introducing lazy imports an improvement over the current state of affairs, our assessment is that such a feature would fall short of truly allowing a project to rein in its dependency structure.

#### Workarounds and Alternatives

There are a number of alternative approaches that have been (and some still are) considered.

* Add syntax to allow for an optional `import` declaration inside declarations:

```d
    void process(import std.stdio)(File input);
    struct Buffered(import std.range)(Range) if (isInputRange!Range)
    {
        ...
    }
```
This has the advantage of being less verbose in case the same module is looked up several times. The disadvantages are a heavier and more ambiguous syntax (two sets of parens for nontemplates, three for templates) and an unclear relationship between the `import`ed entities and the symbols used in the declaration.
* Use `import` as a pseudo-package such that symbols are written like this:

```d
        void process(import.std.stdio.File input);
        struct Buffered(Range) if (import.std.range.isInputRange!Range)
        {
            ...
        }
```
Such an option has an ambiguity problem shown by Timon Gehr: is `import.std.range.isInputRange` looking up symbol `isInputRange` in module/package `std.range`, or the symbol `range.isInputRange` (e.g. a `struct` member) in module/package `std`?
* Stay as close to the existing `import` syntax as possible. This has the advantage of being instantly recognized, but the disadvantage of looking out of place within the declaration:

```d
        void process(File input) import std.stdio;
        struct Buffered(Range) if (isInputRange!Range)
        import std.range;
        {
            ...
        }
```
One syntactical issue is that in this case the semicolon ending the `import` may or may not end the declaration; the scanner (and human reader) would need to look ahead to figure whether a definition continues (by means of an open brace, the `in` keyword, or the `out` keyword), or the declaration ends there.
* Alternatively, the semicolon might be omitted in the approach above. This causes no syntactical ambiguity but makes the hanging `import` declaration even more out of place:
```d
        void process(File input) import std.stdio;
        struct Buffered(Range) if (isInputRange!Range)
        import std.range
        {
            ...
        }
```
* The `with` keyword has been proposed:
```d
        void process(File input) import std.stdio;
        struct Buffered(Range) if (isInputRange!Range)
        with (import std.range)
        {
            ...
        }
```
Arguably this use of `with` is in keeping with its current semantics; for example, `with (EnumName)` introduces the values defined by an enumerated type in the scope it creates.

### Breaking changes / deprecation process

We do not anticipate any breaking changes brought by this language addition. The syntactical construct proposed is currently not accepted.

The inline imports specified with a declaration do not affect its type (e.g. the function type for a function declaration).

The changes to declaration syntax will impact third-party documentation generators, so they would need to be updated. There is an advantage herein---documentation generators (including ddoc itself) can show the user the dependencies that each declaration would incur.

## Copyright & License

Copyright (c) 2016 by the D Language Foundation

Licensed under [Creative Commons Zero 1.0](https://creativecommons.org/publicdomain/zero/1.0/legalcode.txt)

### Reviews
